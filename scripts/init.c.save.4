#include <stdlib.h>
#include <stdio.h>
#include <sys/time.h>
#include <wiringPi.h>
#include <string.h>

// Add TFTGL library
#include <tftgl.h>

// Add NANOVG library
#include <nanovg.h>
#define NANOVG_GLES2_IMPLEMENTATION	// Use GLES 2 implementation.
#include <nanovg_gl.h>
#include <bcm2835.h>

static volatile uint32_t* gpioData = NULL;

#define GPIO_GPFSET0 (BCM2835_GPSET0/4)
#define GPIO_GPFCLR0 (BCM2835_GPCLR0/4)
#define GPIO_WRITE_PIN(pinnum, pinstate) \
	*(gpioData + (pinstate ? GPIO_GPFSET0 : GPIO_GPFCLR0)) = (1 << pinnum);


#define ROWS 2
#define COLS 3

char pressedKey = '\0';
int rowPins[ROWS] = {8, 11};
int colPins[COLS] = {10, 13, 12};

char keys[ROWS][COLS] = {
   {'1', '2', '3', 'A'},
   {'4', '5', '6', 'B'},
   {'7', '8', '9', 'C'},
   {'*', '0', '#', 'D'}
};

void init_keypad()
{
   for (int c = 0; c < COLS; c++) {
      pinMode(colPins[c], OUTPUT);
      digitalWrite(colPins[c], HIGH);
   }

   for (int r = 0; r < ROWS; r++) {
      pinMode(rowPins[0], INPUT);
      pullUpDnControl(rowPins[r], PUD_UP);
   }
}

int findLowRow() {
   for (int r = 0; r < ROWS; r++) {
      if (digitalRead(rowPins[r]) == LOW)
         return r;
   }

   return -1;
}

char get_key() {
   int rowIndex;

   for (int c = 0; c < COLS; c++) {
      digitalWrite(colPins[c], LOW);
      rowIndex = findLowRow();
      if (rowIndex > -1) {
         if (!pressedKey)
            pressedKey = keys[rowIndex][c];
         return pressedKey;
      }
      digitalWrite(colPins[c], HIGH);
   }
   pressedKey = '\0';
   return pressedKey;
}

struct TextBox {
	char * s;
	int len, max_len, x1, y1, x2, y2, font;
	float width;
};

void init(struct TextBox *tbox, int max_len, int x1, int y1, int x2, int y2, float w, int font) {
	tbox->s = (char *)malloc(max_len + 2);
	tbox->s[0] = 0;
	tbox->len = 0;
	tbox->max_len = max_len;
	tbox->x1 = x1;
	tbox->y1 = y1;
	tbox->x2 = x2;
	tbox->y2 = y2;
	tbox->width = w;
	tbox->font = font;
}

void destroy(struct TextBox *tbox) {
	free(tbox->s);
}

void addLetter(struct TextBox *tbox, char c) {
	if (tbox->len < tbox->max_len) {
		tbox->s[tbox->len] = c;
		tbox->len++;
		tbox->s[tbox->len] = 0;
	}
}

void removeLetter(struct TextBox *tbox) {
	if (tbox->len > 0) {
		tbox->s[tbox->len] = 0;
		tbox->len--;
	}
}


void drawBox(struct NVGcontext *vg, int x1, int y1, int x2, int y2, float w) {
	nvgBeginPath(vg);
	nvgMoveTo(vg, x1, y1);
	nvgLineTo(vg, x2, y1);
	nvgLineTo(vg, x2, y2);
	nvgLineTo(vg, x1, y2);
	nvgLineTo(vg, x1, y1);
	nvgStrokeColor(vg, nvgRGBA(0, 0, 0, 255));
	nvgStrokeWidth(vg, w);
	nvgStroke(vg);
}

void draw(struct TextBox *tbox, struct NVGcontext *vg) {
	drawBox(vg, tbox->x1, tbox->y1, tbox->x2, tbox->y2, tbox->width);
	nvgFontFaceId(vg, tbox->font);
	nvgFontSize(vg, 50);
	nvgFillColor(vg, nvgRGBA(0,0,0,255));
	nvgText(vg, tbox->x1 + 10, tbox->y2 - 12, tbox->s, tbox->s + tbox->len);
}


//==============================================================================
int main(int argv, char** argc){
	double pxRatio;
	unsigned int i;


	// Initialize tftgl!
	if(tftglInit(TFTGL_LANDSCAPE) != TFTGL_OK){
		fprintf(stderr, "Failed to initialize TFTGL library! Error: %s\n",
			tftglGetErrorStr());
		return EXIT_FAILURE;
	}

	// Set brightness to full 100%
	tftgSetBrightness(255);

	// Get viewport size
	GLint viewport[4];
	glGetIntegerv(GL_VIEWPORT, viewport);
	printf("TFT display initialized with EGL! Screen size: %dx%d\n",
		viewport[2], viewport[3]);

	GLint width = viewport[2];
	GLint height = viewport[3];

	glClear(GL_COLOR_BUFFER_BIT|GL_STENCIL_BUFFER_BIT);

	struct NVGcontext* vg = nvgCreateGLES2(NVG_ANTIALIAS | NVG_STENCIL_STROKES);

	wiringPiSetup();

  	init_keypad();

//	float bounds[4] = {300, 100, 500, 300};
	int font = nvgCreateFont(vg, "sans", "FreeSans.ttf");
	struct TextBox tb1, tb2, tb3, tb4, tb5;
	init(&tb1, 15, 310, 100, width - 105, 150, 4, font);
	init(&tb2, 10, 95, 100, 210, 150, 0, font);
	init(&tb3, 15, 310, 180, width - 105, 230, 4, font);
	init(&tb4, 10, 95, 180, 210, 230, 0, fon	init(&tb4, 10, 95, 180, 210, 230, 0, font);
t);
	addLetter(&tb2, 'L');
	addLetter(&tb2, 'o');
	addLetter(&tb2, 'g');
	addLetter(&tb2, 'i');
	addLetter(&tb2, 'n');

	addLetter(&tb4, 'P');
	addLetter(&tb4, 'a');
	addLetter(&tb4, 's');
	addLetter(&tb4, 's');
	addLetter(&tb4, 'w');
	addLetter(&tb4, 'o');
	addLetter(&tb4, 'r');
	addLetter(&tb4, 'd');

	while(1) {
    		char x = get_key();

		if (x) {
			printf("pressed: %c\n", x);
			if(x == '6') break;
			else {
				addLetter(&tb1, x);
			}
		}
		delay(100);
		nvgBeginFrame(vg, width, height, 1.0);

		nvgBeginPath(vg);
		nvgMoveTo(vg, 0, 0);
		nvgLineTo(vg, width, 0);
		nvgLineTo(vg, width, height);
		nvgLineTo(vg, 0, height);
		nvgLineTo(vg, 0, 0);
		nvgFillColor(vg, nvgRGBA(255, 255, 255, 255));
		nvgFill(vg);

		draw(&tb1, vg);
		draw(&tb2, vg);
		draw(&tb3, vg);
		draw(&tb4, vg);
		drawBox(vg, 55, 55, width - 55, 275, 4);

		drawBox(vg, 400, 0, 400, 480, 2);

		nvgBeginPath(vg);
		nvgMoveTo(vg, 350, 300);
		nvgLineTo(vg, 450, 300);
		nvgLineTo(vg, 450, 350);
		nvgLineTo(vg, 350, 350);
		nvgLineTo(vg, 350, 300);
		nvgFillColor(vg, nvgRGBA(10, 128, 10, 255));
		nvgFill(vg);
		draw(&tb5, vg);

		nvgEndFrame(vg);
		tftglUploadFbo();
	}


	nvgDeleteGLES2(vg);

	// Terminates everything (GPIO, LCD, and EGL)
	tftglTerminate();

	return EXIT_SUCCESS;
}
